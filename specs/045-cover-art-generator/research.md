# Research: Cover Art Generator

**Feature**: 045-cover-art-generator
**Date**: 2026-02-08

## R1: Gallery Save Flow & Cover Art Injection Point

**Decision**: Inject cover art generation as an `asyncio.create_task()` call immediately after `gallery_service.save_story()` in routes.py

**Rationale**: The gallery save happens synchronously at 5 trigger points in routes.py (lines 709, 955, 1319, 1512, 2963). All follow the same pattern:
```python
gallery_service.save_story(story_session)
```
Adding an async task after each call is minimally invasive. The `save_story()` method writes the JSON file, then the cover task generates the image and updates the JSON file with the cover URL.

**Alternatives considered**:
- Generating cover inside `save_story()` itself: Rejected — would block the save, and `save_story()` is synchronous
- Lazy generation on gallery page load: Rejected — would slow down gallery browsing; the spec requires async pre-generation
- Separate worker queue: Over-engineering for a home server app

## R2: Cover Art Prompt Strategy

**Decision**: Build cover prompt from story title + original prompt + tier cover style. Do NOT analyze scene content.

**Rationale**: The story's original prompt contains the genre, theme, and setting (e.g., "space pirates", "princess in an enchanted forest"). Combined with the title (generated by the AI for the first scene), this provides sufficient context for a thematic cover illustration. Reading scene content would add complexity and token cost for minimal visual improvement.

**Prompt template**:
```
A book cover illustration for a story titled "{title}".
Theme: {prompt}.
Style: {tier_cover_style}. {art_style_addition}
Compose as a single dramatic illustration suitable for a book cover.
No text, no words, no lettering.
```

**Alternatives considered**:
- Summarize all scenes for the cover prompt: Rejected — expensive AI call just to build a prompt, and the original prompt already captures the theme
- Use the first scene's image_prompt: Rejected — too specific to one scene; a cover should be thematic, not scene-specific

## R3: Tier-Specific Cover Styling

**Decision**: Define tier-specific cover style strings that get injected into the cover prompt

**Rationale**: Each tier has a distinct visual identity. Cover styles should match.

| Tier | Cover Style |
|------|-------------|
| kids | "Bright, colorful children's book cover illustration, whimsical, friendly, cheerful atmosphere, picture book aesthetic" |
| bible | "Warm, reverent Bible storybook cover illustration, golden light, classical painting style, inspirational" |
| nsfw | "Stylized, atmospheric book cover art, bold composition, cinematic lighting, mature aesthetic" |

**Alternatives considered**:
- Reuse tier `image_style` directly: Rejected — image_style is designed for scene illustrations, not book covers (e.g., kids image_style says "no scary elements" which is irrelevant for a cover)

## R4: SavedStory Model Extension

**Decision**: Add two fields to SavedStory: `cover_art_url: Optional[str] = None` and `cover_art_status: str = "none"`

**Rationale**: Follows the same pattern as `Image.status` and `Image.url`. Default values ensure backward compatibility — existing gallery JSON files will deserialize correctly with Pydantic defaults. Status values: "none" (never attempted), "generating", "complete", "failed".

**Alternatives considered**:
- Single `cover_art_url` field (None = no cover): Rejected — can't distinguish "never generated" from "generation failed" from "still generating"
- Separate Cover model: Over-engineering for two fields

## R5: Async Cover Generation & JSON Update

**Decision**: The async cover task generates the image, then re-reads and updates the story JSON file on disk

**Rationale**: Since `save_story()` writes the JSON first (without cover), the async task needs to update the file after the image is ready. This is safe because gallery JSON files are written atomically (write_text) and the cover task is the only writer after the initial save.

**Flow**:
1. `save_story()` writes JSON with `cover_art_status: "generating"`
2. Async task calls `image_service.generate_image()` with cover prompt
3. On success: re-read JSON, set `cover_art_url` and `cover_art_status: "complete"`, re-write
4. On failure: re-read JSON, set `cover_art_status: "failed"`, re-write

**Alternatives considered**:
- Keep cover status in memory only: Rejected — status would be lost on server restart
- Write a separate cover metadata file: Over-engineering; updating the existing JSON is simpler

## R6: Gallery Template Thumbnail Logic

**Decision**: Template checks `story.cover_art_url` and `story.cover_art_status == "complete"` first, then falls back to first scene image

**Rationale**: Simple conditional in Jinja2. No polling or JavaScript needed — the cover will appear on the next gallery page load after generation completes.

**Alternatives considered**:
- JavaScript polling on gallery page: Over-engineering — covers generate in ~30s, and users rarely stare at the gallery waiting for a cover
- Show a "generating" placeholder: Nice but unnecessary complexity; the first scene image is a fine temporary thumbnail

## R7: Regenerate Cover Endpoint

**Decision**: `POST /{tier}/gallery/{story_id}/regenerate-cover` endpoint in routes.py

**Rationale**: Follows existing patterns (e.g., `POST /story/image/{scene_id}/regenerate`). Loads the SavedStory from disk, updates status to "generating", kicks off async task, redirects back to the reader page. Available from the gallery detail/reader view.

**Alternatives considered**:
- PUT endpoint: Not standard for this project (all mutations use POST)
- AJAX-based: Unnecessary complexity; a form POST with redirect is simpler and matches existing patterns
